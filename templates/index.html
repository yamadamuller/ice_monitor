<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Ice monitor</title>
        <link rel="icon" type="image/x-icon" href="https://nuem.ct.utfpr.edu.br/wp-content/uploads/2021/05/favicon.ico">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Red+Hat+Text:wght@400;700&display=swap" rel="stylesheet">
        <style>
            body {
                font-family: 'Red Hat Text', sans-serif;
                text-align: justify;
                text-justify: inter-word;
                margin: 0;
                padding: 0;
                position: relative;
                min-height: 100vh;
            }

            .highlight-color{
                color: #4A88C3;
            }

            .content {
                max-width: 800px;
                margin: 100px auto 40px;
                padding: 0 20px;
                line-height: 1.6;
                font-size: 1.1rem;
                color: #333;
            }

            .fixed{
                position: fixed;
            }

            .top-0{
                top: 0;
            }

            .left-0{
                left: 0;
            }

            .right-0{
                right: 20;
            }

            .transition-all {
                transition-property: all;
                transition-timing-function: cubic-bezier(.4,0,.2,1);
                transition-duration: .15s;
            }

            .duration-300 {
                animation-duration: .3s;
            }

            .py-5 {
                padding-top: 1.25rem;
                padding-bottom: 1.25rem;
            }

             .items-center {
                align-items: center;
            }

            .img-responsive {
                max-width: 10%;
            }

            .ico_enhanced {
                width: 200%;
                height: 200%;
            }

            .canvas-title {
                text-align: center;
                font-weight: bold;
                margin-bottom: 4px;
            }
            .freq-row {
                display: flex;
                flex-direction: row;  /* side-by-side frequency blocks */
                gap: 20px;
                justify-content: flex-start;
                align-items: flex-start;
            }

            .column-block {
                display: flex;
                flex-direction: column;
                align-items: center;
                min-width: 300px;
            }

            .heatmap-canvas {
                border: 1px solid #ccc;
                margin-bottom: 4px;
            }

            .label {
                text-align: center;
                font-size: 0.9rem;
                margin-bottom: 4px;
            }

            .timestamp-canvas {
                border-top: 1px solid #000;
                margin-top: 2px;
            }


        </style>
    </head>

    <body class="content" style="margin-left:500px;">
        <div>
             <a class="flex items-center" href="/">
                <img src="https://www.udiscovermusic.com/wp-content/uploads/2020/04/Ice-Cube-GettyImages-74305254.jpg"
                     alt="cube_logo" width="35%" height="35%">
            </a>
            <h1 class="highlight-color">Ice monitor</h1>
            <button id="startBtn" onclick="startAcquisition()">Start monitoring</button>
            <button id="stopBtn"  onclick="stopAcquisition()" disabled>Stop monitoring</button>
            <pre id="monitoredFile" class="highlight-color"></pre>
        </div>

        <div id="heatmapContainer" class="freq-row"></div>


        <script>
            const sweepedFreqs = {{ freqs | tojson }};
            let stopUpdate = false;
            let pollingInterval = null;
            let freqData = {};
            const canvasWidth = 300;  // fixed canvas width
            const canvasHeight = 200; // per heatmap
            const modeLabels = [
                "d:10-1", "d:9-10", "d:8-9", "d:7-8", "d:6-7",
                "d:5-6", "d:4-5", "d:3-4", "d:2-3", "d:1-2"
            ];

            document.addEventListener("DOMContentLoaded", () => {
                createHeatmapBlocks();
            });

            function createHeatmapBlocks() {
                const container = document.getElementById("heatmapContainer");

                sweepedFreqs.forEach(freq => {
                    const block = document.createElement("div");
                    block.className = "column-block";

                    block.innerHTML = `
                        <div class="canvas-title">Capacitance (${freq} Hz)</div>
                        <canvas id="cap_${freq}" width="${canvasWidth}" height="${canvasHeight}" class="heatmap-canvas"></canvas>

                        <div class="canvas-title">Resistance (${freq} Hz)</div>
                        <canvas id="res_${freq}" width="${canvasWidth}" height="${canvasHeight}" class="heatmap-canvas"></canvas>

                        <canvas id="ts_${freq}" width="${canvasWidth}" height="20" class="timestamp-canvas"></canvas>
                    `;

                    container.appendChild(block);
                    freqData[freq] = { cap: [], res: [], ts: [] };
                });
            }

            function startPolling() {
                pollingInterval = setInterval(fetchAllHeatmaps, 500);
            }

            function stopPolling() {
                clearInterval(pollingInterval);
            }

            async function fetchAllHeatmaps() {
                for (const freq of sweepedFreqs) {
                    try {
                        const response = await fetch(`/api/${freq}Hz`);
                        if (!response.ok) continue;
                        const data = await response.json();

                        if (!data.cap_mtx || !data.res_mtx || !data.timestamp) continue;

                        freqData[freq] = {
                            cap: data.cap_mtx,
                            res: data.res_mtx,
                            ts: data.timestamp
                        };

                        drawHeatmap(`cap_${freq}`, freqData[freq].cap);
                        drawHeatmap(`res_${freq}`, freqData[freq].res);
                        drawTimestamps(`ts_${freq}`, freqData[freq].ts);

                    } catch (err) {
                        console.error(`Error fetching ${freq} Hz`, err);
                    }
                }
            }

            function drawHeatmap(canvasId, matrix) {
                const canvas = document.getElementById(canvasId);
                if (!canvas || !matrix.length) return;

                const ctx = canvas.getContext("2d");
                const T = matrix.length;    // timestamps (horizontal)
                const M = matrix[0].length; // modes (vertical)
                console.log(T)
                const leftMargin = 40;      // space for mode labels
                const heatmapWidth = canvas.width - leftMargin;
                const heatmapHeight = canvas.height;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const pxPerCol = heatmapWidth / T;
                const pxPerRow = heatmapHeight / M;

                // Flatten matrix to normalize colors
                const flat = matrix.flat();
                const min = Math.min(...flat);
                const max = Math.max(...flat);

                // Draw heatmap with reversed y-axis
                for (let t = 0; t < T; t++) {
                    for (let m = 0; m < M; m++) {
                        const v = matrix[t][m];
                        const norm = (v - min) / (max - min + 1e-12);
                        const color = Math.floor(norm * 255);
                        ctx.fillStyle = `rgb(${color},0,${255 - color})`;

                        // Reverse y-axis: mode 0 -> bottom, mode 9 -> top
                        const y = (M - 1 - m) * pxPerRow;
                        ctx.fillRect(leftMargin + t * pxPerCol, y, pxPerCol, pxPerRow);
                    }
                }

                // Draw y-axis labels (reversed)
                ctx.fillStyle = "#000";
                ctx.font = "12px Arial";
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";

                for (let m = 0; m < M; m++) {
                    const y = (M - 1 - m) * pxPerRow + pxPerRow / 2;
                    const label = modeLabels[m] || `Mode ${m}`;
                    ctx.fillText(label, leftMargin - 5, y);
                }
            }

            function drawTimestamps(canvasId, tsArray) {
                const canvas = document.getElementById(canvasId);
                if (!canvas || !tsArray.length) return;

                const ctx = canvas.getContext("2d");
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = "#000";
                ctx.font = "10px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                const nLabels = 4; // number of timestamps to display
                const step = Math.max(1, Math.floor(tsArray.length / (nLabels - 1)));
                console.log(tsArray.length);
                for (let i = 0; i < tsArray.length; i += step) {
                    const date = new Date(tsArray[i]);
                    const label = `${date.getHours()}:${String(date.getMinutes()).padStart(2,"0")}:${String(date.getSeconds()).padStart(2,"0")}`;
                    const x = i * canvas.width / tsArray.length + canvas.width / tsArray.length / 2;
                    ctx.fillText(label, x, canvas.height / 2);
                }

                // Ensure the last timestamp is always displayed
                const lastDate = new Date(tsArray[tsArray.length - 1]);
                const lastLabel = `${lastDate.getHours()}:${String(lastDate.getMinutes()).padStart(2,"0")}:${String(lastDate.getSeconds()).padStart(2,"0")}`;
                const lastX = canvas.width - canvas.width / tsArray.length / 2;
                ctx.fillText(lastLabel, lastX, canvas.height / 2);
            }

            async function startAcquisition() {
                stopUpdate = false;
                document.getElementById("startBtn").disabled = true;
                document.getElementById("stopBtn").disabled = false;
                await fetch("/monitor_start");
                startPolling();
            }

            async function stopAcquisition() {
                stopUpdate = true;
                document.getElementById("startBtn").disabled = false;
                document.getElementById("stopBtn").disabled = true;
                await fetch("/monitor_stop");
                stopPolling();
            }


        </script>
    </body>
</html>
